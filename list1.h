/*
реализация односвязного списка с выделенным элементом
пока без итератора, перегрузки конструктора копирования и присваивания
*/
#include"my.h"  //если в список поместить объекты класса, описанного здесь

typedef   int T;  // будет доступен только список целых, 
//при изменении T на другой тип (например, Student) список будет строится из этих объектов
class List{
	class Node{ //вспомогательный класс списка == узел 
		T v;//поле, куда сохраняем объекты, которые нужно связать в список
		Node *next;//поле для хранения адреса следующего узла
		public:
		Node();//конструктор узла без параметров
		Node(const  T &v);//конструктор узла с параметрами
		friend class List; //чтобы список имел доступ к своим узлам
	};
	Node *base,*cur;//выделенный и текущий элементы
	public:
	class iterator{
		List *l;
		Node *cur;
		public:
		iterator(const List *);
		T & operator*();
		iterator & operator ++(void);
		int operator !=(Node *);
		friend class List;
	};
	iterator Begin()const; //const-метод может применяться в конструкторе копирования и присваивания (и везде, где аргумент имеет тип const)
	Node * End() const;

	int Del();//удаляет следующий и возвращает информацию об успехе операции
	void Ins(const T&);//вставляет перед следующим узел с данными  и возвращает информацию об успехе операции
	List();//конструктор пустого списка
	~List();//деструктор списка
	void Clean();//вспомогательная функция для деструктора и очистки списка вручную
	void GoToBegin();//текущий встает в начала (список при этом не меняется)
	int GoToNext();//текущий встает на следующий (список при этом не меняется)
	T& Get();//возвращаем объект, который хранится в текущем узле

	List(const List &);//конструктор копии
	List(List&&l);//конструктор копирования перемещением, нужен для оптимизации (если она требуется)
 	List& operator=(const List&l);//перегрузка присваивания  копированием
	List& operator=(List &&l);//присваивание перемещением, аналогично конструктору копии

	int swap();//эта функция не относится к базовым для списка 
	int swap1();//более простая модификация swap
	void sort();//сортировка пузырьком, для использования в классе Student требуется перегрузка там оператора >
	Node *del();//Del без очистки
	void ins(Node *);// Ins без выделения памяти
	void foo();//циклический сдвиг списка
	friend ostream & operator<<(ostream &,const List &);
//меняем местами 2 узла, при этом данные не копируются!
};


#include"list.h" 
List::Node::Node(){ //используем для построения выделенного элемента, в нем данные не хранятся
	this->v=T();
}
List::Node::Node(const T &v){//строит узел и загружает данные на хранение
	this->v=T(v);
}
//_________________________
List::List(){//создает список, состоящий из выделенного элемента (пустой)
	base=new Node();
	base->next=base;
	cur=base;
}
List::~List(){
	cur=base;//очистка всего списка
	Clean();
}
int List::Del(){ //удаляет следующий элемент, т.е.  next
	if(cur->next==cur)//если список пуст, удалять элемент нельзя
		return 0;
	Node *tmp=cur->next;//запомним указатель на следующий
	cur->next=cur->next->next;//объявляем, что теперь следующим будет next->next
	delete tmp;//стираем вырезанный элемент (освобождаем ранее выделенную под этот узел память
	return 1; //в случае успеха возвращаем 1
}
void List::Clean(){
	if(!base)
		return;
	while(Del())//пока список не пуст, удаляем элемент
		;//нужно понимать, что сдвигаться по списку не надо
	delete base; //пустой список тоже требовал выделения памяти
}
void List::Ins(const T&v){ //вставка элемента происходит рядом (справа) с текущим
	Node *tmp=new Node(v); //строим новый узел
	tmp->next=cur->next;//следующим для tmp будет next
	cur->next=tmp; //вклеиваем новый узел в список
}
void List::GoToBegin(){//передвигаем текущий в начало списка
	cur=base;
}
int List::GoToNext(){ //передвигаем текущий в следующую позицию
	if(cur->next==base)
		return 0;
	cur=cur->next;
		return 1;
}
T& List::Get(){
	return cur->v;
}
int List::swap(){ //меняем местами(если возможно) следующий с тем, 
//который является следующим для следующего, например, для списка
// ... 1 2 3 4 5 , где текущий -- 1, результатом будет ....1 3 2 4 5
	if(cur->next==base||cur->next->next==base)
		return 0; //base перемещать не будем
	Node *tmp=cur->next; //запомнили узел с 2 
	cur->next=cur->next->next; // вырезали 2,  .. 1 3 4 5   
	tmp->next=cur->next->next; //за 2 должна следовать 4
	cur->next->next=tmp;//вклеиваем за 3 готовый узел с 2, получаем 1 3 2 4 5
	return 1;
}
